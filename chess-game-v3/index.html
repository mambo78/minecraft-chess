<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathias Chess</title>
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #4a6741);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr auto 300px;
            gap: 20px;
            align-items: start;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .game-icon {
            font-size: 2rem;
        }

        /* Turn Indicator */
        .turn-indicator {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .player-indicator {
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .player-indicator.white {
            background: #ecf0f1;
            color: #2c3e50;
        }

        .player-indicator.black {
            background: #34495e;
            color: white;
        }

        .current-turn {
            background: #f39c12 !important;
            color: white !important;
            border-color: #e67e22;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
        }

        /* Chess Board */
        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            gap: 0;
            border: 3px solid #34495e;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            font-size: 36px;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.6);
        }

        .square.selected {
            background-color: #f39c12 !important;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
        }

        .square.valid-move {
            background-color: #2ecc71 !important;
        }

        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(46, 204, 113, 0.7);
            border-radius: 50%;
        }

        .square.in-check {
            background-color: #e74c3c !important;
            animation: check-pulse 1s infinite;
        }

        @keyframes check-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Control Panel */
        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-section {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .section-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #f39c12;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-icon {
            font-size: 1rem;
        }

        /* Game Mode */
        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .mode-btn.human {
            background: #3498db;
            color: white;
        }

        .mode-btn.ai {
            background: #27ae60;
            color: white;
        }

        .mode-btn.active {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        /* AI Controls */
        .ai-controls {
            margin-top: 15px;
        }

        .ai-controls.hidden {
            display: none;
        }

        .difficulty-selector {
            margin-bottom: 15px;
        }

        .difficulty-selector label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #ecf0f1;
        }

        .difficulty-selector select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: #34495e;
            color: white;
            cursor: pointer;
        }

        .ai-status {
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            margin-top: 10px;
        }

        .ai-status.ready {
            background: #27ae60;
            color: white;
        }

        .ai-status.thinking {
            background: #f39c12;
            color: white;
        }

        .ai-status.loading {
            background: #3498db;
            color: white;
        }

        .ai-status.error {
            background: #e74c3c;
            color: white;
        }

        /* Theme Controls */
        .theme-selector select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #34495e;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        .random-theme-btn {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border: none;
            border-radius: 8px;
            background: #f39c12;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .random-theme-btn:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        /* Game Controls */
        .control-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            background: #f39c12;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .control-btn:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .control-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
        }

        /* Captured Pieces */
        .captured-pieces {
            min-height: 100px;
        }

        .captured-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .captured-piece {
            font-size: 24px;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }

        /* Themes */
        .theme-classic .square.light { background-color: #f0d9b5; }
        .theme-classic .square.dark { background-color: #b58863; }

        .theme-neon .square.light { background-color: #00ffff; }
        .theme-neon .square.dark { background-color: #ff00ff; }

        .theme-wood .square.light { background-color: #deb887; }
        .theme-wood .square.dark { background-color: #8b4513; }

        .theme-ocean .square.light { background-color: #87ceeb; }
        .theme-ocean .square.dark { background-color: #4682b4; }

        .theme-sunset .square.light { background-color: #ffd700; }
        .theme-sunset .square.dark { background-color: #ff4500; }

        .theme-forest .square.light { background-color: #90ee90; }
        .theme-forest .square.dark { background-color: #228b22; }

        .theme-royal .square.light { background-color: #dda0dd; }
        .theme-royal .square.dark { background-color: #8b008b; }

        /* Pawn Promotion Dialog */
        .promotion-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .promotion-content {
            background: #2c3e50;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 2px solid #f39c12;
        }

        .promotion-title {
            font-size: 1.5rem;
            color: #f39c12;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .promotion-pieces {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-piece {
            width: 80px;
            height: 80px;
            background: #34495e;
            border: 2px solid #7f8c8d;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .promotion-piece:hover {
            background: #f39c12;
            border-color: #e67e22;
            transform: scale(1.1);
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
                text-align: center;
            }

            .control-panel {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .control-section {
                flex: 1;
                min-width: 250px;
            }
        }

        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }

            .square {
                width: 45px;
                height: 45px;
                font-size: 28px;
            }

            .control-section {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Header -->
        <div class="header">
            <h1 class="game-title">
                <span class="game-icon">🎮</span>
                Mathias Chess
                <span class="game-icon">🎮</span>
            </h1>
            
            <div class="turn-indicator">
                <div class="player-indicator white current-turn" id="white-indicator">White</div>
                <div class="player-indicator black" id="black-indicator">Black's Turn</div>
            </div>
        </div>

        <!-- Chess Board -->
        <div class="board-container">
            <div class="chess-board theme-classic" id="chess-board">
                <!-- Board squares will be generated by JavaScript -->
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <!-- Game Mode -->
            <div class="control-section">
                <div class="section-title">
                    <span class="section-icon">🎯</span>
                    Game Mode
                </div>
                <div class="mode-buttons">
                    <button class="mode-btn human active" id="human-mode">👥 vs Human</button>
                    <button class="mode-btn ai" id="ai-mode">🤖 vs Stockfish</button>
                </div>
                <div class="ai-controls hidden" id="ai-controls">
                    <div class="difficulty-selector">
                        <label>Difficulty:</label>
                        <select id="difficulty-select">
                            <option value="1">Easy</option>
                            <option value="5">Medium</option>
                            <option value="10" selected>Hard</option>
                            <option value="15">Expert</option>
                            <option value="20">Master</option>
                        </select>
                    </div>
                    <div class="ai-status loading" id="ai-status">🔄 Loading Stockfish...</div>
                </div>
            </div>

            <!-- Themes -->
            <div class="control-section">
                <div class="section-title">
                    <span class="section-icon">🎨</span>
                    Themes
                </div>
                <div class="theme-selector">
                    <select id="theme-select">
                        <option value="classic">Classic Chess</option>
                        <option value="neon">Neon Dreams</option>
                        <option value="wood">Wooden Board</option>
                        <option value="ocean">Ocean Blues</option>
                        <option value="sunset">Sunset Glow</option>
                        <option value="forest">Forest Green</option>
                        <option value="royal">Royal Purple</option>
                    </select>
                </div>
                <button class="random-theme-btn" id="random-theme">🎲 Random Theme</button>
            </div>

            <!-- Game Controls -->
            <div class="control-section">
                <div class="section-title">Game Controls</div>
                <button class="control-btn" id="new-game">🔄 New Game</button>
                <button class="control-btn" id="undo-move">↩️ Undo Move</button>
                <button class="control-btn" id="show-hint">💡 Show Hint</button>
            </div>

            <!-- Captured Pieces -->
            <div class="control-section">
                <div class="section-title">
                    <span class="section-icon">👑</span>
                    Captured Pieces
                </div>
                <div class="captured-pieces">
                    <div>White captured:</div>
                    <div class="captured-list" id="white-captured"></div>
                    <div style="margin-top: 10px;">Black captured:</div>
                    <div class="captured-list" id="black-captured"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pawn Promotion Dialog -->
    <div class="promotion-dialog" id="promotion-dialog">
        <div class="promotion-content">
            <div class="promotion-title">Choose promotion piece:</div>
            <div class="promotion-pieces" id="promotion-pieces">
                <div class="promotion-piece" data-piece="q"></div>
                <div class="promotion-piece" data-piece="r"></div>
                <div class="promotion-piece" data-piece="b"></div>
                <div class="promotion-piece" data-piece="n"></div>
            </div>
        </div>
    </div>

    <script>
        // Chess Game Implementation
        class ChessGame {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.gameMode = 'human';
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                this.enPassantTarget = null;
                this.kingPositions = { white: [7, 4], black: [0, 4] };
                this.checkStatus = { white: false, black: false };
                
                this.pieceSymbols = {
                    white: { k: '♔', q: '♕', r: '♖', b: '♗', n: '♘', p: '♙' },
                    black: { k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟' }
                };
                
                this.stockfishEngine = new StockfishEngine();
                this.promotionCallback = null;
                
                this.initializeBoard();
                this.setupEventListeners();
            }

            createInitialBoard() {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // White pieces
                board[7] = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'].map(piece => ({ type: piece, color: 'white' }));
                board[6] = Array(8).fill(null).map(() => ({ type: 'p', color: 'white' }));
                
                // Black pieces
                board[0] = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'].map(piece => ({ type: piece, color: 'black' }));
                board[1] = Array(8).fill(null).map(() => ({ type: 'p', color: 'black' }));
                
                return board;
            }

            initializeBoard() {
                const boardElement = document.getElementById('chess-board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.addEventListener('click', () => this.handleSquareClick(row, col));
                        boardElement.appendChild(square);
                    }
                }
                
                this.updateDisplay();
            }

            handleSquareClick(row, col) {
                if (this.gameMode === 'ai' && this.currentPlayer === 'black') {
                    return; // Don't allow clicks during AI turn
                }

                const piece = this.board[row][col];
                
                if (this.selectedSquare) {
                    const [selectedRow, selectedCol] = this.selectedSquare;
                    
                    if (row === selectedRow && col === selectedCol) {
                        this.clearSelection();
                        return;
                    }
                    
                    if (this.isValidMove(selectedRow, selectedCol, row, col)) {
                        const move = {
                            from: [selectedRow, selectedCol],
                            to: [row, col],
                            piece: this.board[selectedRow][selectedCol],
                            captured: this.board[row][col],
                            castling: null,
                            enPassant: null,
                            promotion: null
                        };

                        // Check for pawn promotion
                        if (move.piece.type === 'p' && (row === 0 || row === 7)) {
                            this.showPromotionDialog(move);
                            return;
                        }

                        this.executeMove(move);
                        this.clearSelection();
                        
                        if (this.gameMode === 'ai' && this.currentPlayer === 'black') {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    } else {
                        if (piece && piece.color === this.currentPlayer) {
                            this.selectSquare(row, col);
                        } else {
                            this.clearSelection();
                        }
                    }
                } else {
                    if (piece && piece.color === this.currentPlayer) {
                        this.selectSquare(row, col);
                    }
                }
            }

            selectSquare(row, col) {
                this.selectedSquare = [row, col];
                this.updateDisplay();
                this.highlightValidMoves(row, col);
            }

            clearSelection() {
                this.selectedSquare = null;
                this.updateDisplay();
            }

            highlightValidMoves(row, col) {
                const squares = document.querySelectorAll('.square');
                squares.forEach(square => {
                    square.classList.remove('valid-move');
                    const r = parseInt(square.dataset.row);
                    const c = parseInt(square.dataset.col);
                    if (this.isValidMove(row, col, r, c)) {
                        square.classList.add('valid-move');
                    }
                });
            }

            isValidMove(fromRow, fromCol, toRow, toCol) {
                const piece = this.board[fromRow][fromCol];
                if (!piece || piece.color !== this.currentPlayer) return false;

                const target = this.board[toRow][toCol];
                if (target && target.color === piece.color) return false;

                // Basic piece movement validation
                if (!this.isValidPieceMove(piece, fromRow, fromCol, toRow, toCol)) return false;

                // Check if move would leave king in check
                const tempMove = this.simulateMove(fromRow, fromCol, toRow, toCol);
                if (this.isKingInCheck(piece.color, tempMove.board)) {
                    return false;
                }

                return true;
            }

            isValidPieceMove(piece, fromRow, fromCol, toRow, toCol) {
                const dx = Math.abs(toRow - fromRow);
                const dy = Math.abs(toCol - fromCol);
                const target = this.board[toRow][toCol];

                switch (piece.type) {
                    case 'p': // Pawn
                        const direction = piece.color === 'white' ? -1 : 1;
                        const startRow = piece.color === 'white' ? 6 : 1;
                        
                        // Forward move
                        if (fromCol === toCol && !target) {
                            if (toRow === fromRow + direction) return true;
                            if (fromRow === startRow && toRow === fromRow + 2 * direction) return true;
                        }
                        // Capture
                        if (dy === 1 && toRow === fromRow + direction && target) return true;
                        // En passant
                        if (this.enPassantTarget && 
                            this.enPassantTarget[0] === toRow && this.enPassantTarget[1] === toCol &&
                            dy === 1 && toRow === fromRow + direction) return true;
                        break;

                    case 'r': // Rook
                        if ((dx === 0 || dy === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol)) return true;
                        break;

                    case 'n': // Knight
                        if ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) return true;
                        break;

                    case 'b': // Bishop
                        if (dx === dy && this.isPathClear(fromRow, fromCol, toRow, toCol)) return true;
                        break;

                    case 'q': // Queen
                        if ((dx === 0 || dy === 0 || dx === dy) && this.isPathClear(fromRow, fromCol, toRow, toCol)) return true;
                        break;

                    case 'k': // King
                        if (dx <= 1 && dy <= 1) return true;
                        // Castling
                        if (dx === 0 && dy === 2) {
                            return this.canCastle(piece.color, toCol > fromCol ? 'kingside' : 'queenside');
                        }
                        break;
                }
                return false;
            }

            isPathClear(fromRow, fromCol, toRow, toCol) {
                const dx = Math.sign(toRow - fromRow);
                const dy = Math.sign(toCol - fromCol);
                let row = fromRow + dx;
                let col = fromCol + dy;

                while (row !== toRow || col !== toCol) {
                    if (this.board[row][col]) return false;
                    row += dx;
                    col += dy;
                }
                return true;
            }

            canCastle(color, side) {
                if (!this.castlingRights[color][side]) return false;
                if (this.checkStatus[color]) return false;

                const row = color === 'white' ? 7 : 0;
                const kingCol = 4;
                const rookCol = side === 'kingside' ? 7 : 0;
                const direction = side === 'kingside' ? 1 : -1;

                // Check if squares between king and rook are empty
                for (let col = kingCol + direction; col !== rookCol; col += direction) {
                    if (this.board[row][col]) return false;
                }

                // Check if king would pass through check
                for (let col = kingCol; col !== kingCol + 3 * direction; col += direction) {
                    const tempBoard = this.copyBoard();
                    tempBoard[row][col] = tempBoard[row][kingCol];
                    tempBoard[row][kingCol] = null;
                    if (this.isKingInCheck(color, tempBoard)) return false;
                }

                return true;
            }

            executeMove(move) {
                const [fromRow, fromCol] = move.from;
                const [toRow, toCol] = move.to;
                const piece = move.piece;

                // Handle captured pieces
                if (move.captured) {
                    this.capturedPieces[move.captured.color].push(move.captured.type);
                }

                // Handle en passant capture
                if (piece.type === 'p' && this.enPassantTarget &&
                    toRow === this.enPassantTarget[0] && toCol === this.enPassantTarget[1]) {
                    const capturedRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                    const capturedPiece = this.board[capturedRow][toCol];
                    this.board[capturedRow][toCol] = null;
                    this.capturedPieces[capturedPiece.color].push(capturedPiece.type);
                    move.enPassant = { row: capturedRow, col: toCol, piece: capturedPiece };
                }

                // Handle castling
                if (piece.type === 'k' && Math.abs(toCol - fromCol) === 2) {
                    const rookFromCol = toCol > fromCol ? 7 : 0;
                    const rookToCol = toCol > fromCol ? toCol - 1 : toCol + 1;
                    const rook = this.board[fromRow][rookFromCol];
                    this.board[fromRow][rookToCol] = rook;
                    this.board[fromRow][rookFromCol] = null;
                    move.castling = { rookFrom: [fromRow, rookFromCol], rookTo: [fromRow, rookToCol] };
                }

                // Move the piece
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;

                // Handle pawn promotion (if already set)
                if (move.promotion) {
                    this.board[toRow][toCol] = { type: move.promotion, color: piece.color };
                }

                // Update king position
                if (piece.type === 'k') {
                    this.kingPositions[piece.color] = [toRow, toCol];
                }

                // Update castling rights
                if (piece.type === 'k') {
                    this.castlingRights[piece.color].kingside = false;
                    this.castlingRights[piece.color].queenside = false;
                } else if (piece.type === 'r') {
                    if (fromCol === 0) this.castlingRights[piece.color].queenside = false;
                    if (fromCol === 7) this.castlingRights[piece.color].kingside = false;
                }

                // Set en passant target
                this.enPassantTarget = null;
                if (piece.type === 'p' && Math.abs(toRow - fromRow) === 2) {
                    this.enPassantTarget = [(fromRow + toRow) / 2, fromCol];
                }

                // Add to move history
                this.moveHistory.push(move);

                // Update check status
                this.updateCheckStatus();

                // Switch turns
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.updateDisplay();
            }

            showPromotionDialog(move) {
                const dialog = document.getElementById('promotion-dialog');
                const pieces = document.getElementById('promotion-pieces');
                const color = move.piece.color;
                
                // Update piece symbols
                const promotionPieces = pieces.querySelectorAll('.promotion-piece');
                promotionPieces[0].textContent = this.pieceSymbols[color]['q']; // Queen
                promotionPieces[1].textContent = this.pieceSymbols[color]['r']; // Rook
                promotionPieces[2].textContent = this.pieceSymbols[color]['b']; // Bishop
                promotionPieces[3].textContent = this.pieceSymbols[color]['n']; // Knight
                
                dialog.style.display = 'flex';
                
                // Remove existing listeners
                promotionPieces.forEach(piece => {
                    piece.replaceWith(piece.cloneNode(true));
                });
                
                // Add new listeners
                const newPromotionPieces = document.getElementById('promotion-pieces').querySelectorAll('.promotion-piece');
                newPromotionPieces.forEach(piece => {
                    piece.addEventListener('click', () => {
                        move.promotion = piece.dataset.piece;
                        dialog.style.display = 'none';
                        this.executeMove(move);
                        this.clearSelection();
                        
                        if (this.gameMode === 'ai' && this.currentPlayer === 'black') {
                            setTimeout(() => this.makeAIMove(), 500);
                        }
                    });
                });
            }

            simulateMove(fromRow, fromCol, toRow, toCol) {
                const board = this.copyBoard();
                const piece = board[fromRow][fromCol];
                board[toRow][toCol] = piece;
                board[fromRow][fromCol] = null;
                return { board };
            }

            copyBoard() {
                return this.board.map(row => row.map(cell => cell ? { ...cell } : null));
            }

            isKingInCheck(color, board = null) {
                if (!board) board = this.board;
                const kingPos = this.findKingPosition(color, board);
                if (!kingPos) return false;

                // Check if any opponent piece can attack the king
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.color !== color) {
                            if (this.canPieceAttack(piece, row, col, kingPos[0], kingPos[1], board)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            findKingPosition(color, board) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.type === 'k' && piece.color === color) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }

            canPieceAttack(piece, fromRow, fromCol, toRow, toCol, board) {
                // Similar to isValidPieceMove but for attack patterns
                const dx = Math.abs(toRow - fromRow);
                const dy = Math.abs(toCol - fromCol);

                switch (piece.type) {
                    case 'p':
                        const direction = piece.color === 'white' ? -1 : 1;
                        return dy === 1 && toRow === fromRow + direction;
                    case 'r':
                        return (dx === 0 || dy === 0) && this.isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol);
                    case 'n':
                        return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);
                    case 'b':
                        return dx === dy && this.isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol);
                    case 'q':
                        return (dx === 0 || dy === 0 || dx === dy) && this.isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol);
                    case 'k':
                        return dx <= 1 && dy <= 1;
                }
                return false;
            }

            isPathClearOnBoard(board, fromRow, fromCol, toRow, toCol) {
                const dx = Math.sign(toRow - fromRow);
                const dy = Math.sign(toCol - fromCol);
                let row = fromRow + dx;
                let col = fromCol + dy;

                while (row !== toRow || col !== toCol) {
                    if (board[row][col]) return false;
                    row += dx;
                    col += dy;
                }
                return true;
            }

            updateCheckStatus() {
                this.checkStatus.white = this.isKingInCheck('white');
                this.checkStatus.black = this.isKingInCheck('black');
            }

            async makeAIMove() {
                if (this.currentPlayer !== 'black' || this.gameMode !== 'ai') return;

                const move = await this.stockfishEngine.getBestMove(this.getFEN());
                if (move) {
                    this.applyAIMove(move);
                }
            }

            applyAIMove(moveString) {
                // Parse UCI move format (e.g., "e2e4", "e7e8q")
                const fromCol = moveString.charCodeAt(0) - 97;
                const fromRow = 8 - parseInt(moveString[1]);
                const toCol = moveString.charCodeAt(2) - 97;
                const toRow = 8 - parseInt(moveString[3]);
                const promotion = moveString[4] || null;

                const move = {
                    from: [fromRow, fromCol],
                    to: [toRow, toCol],
                    piece: this.board[fromRow][fromCol],
                    captured: this.board[toRow][toCol],
                    castling: null,
                    enPassant: null,
                    promotion: promotion
                };

                this.executeMove(move);
            }

            getFEN() {
                // Generate FEN notation for current position
                let fen = '';
                
                // Board
                for (let row = 0; row < 8; row++) {
                    let empty = 0;
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            if (empty > 0) {
                                fen += empty;
                                empty = 0;
                            }
                            let symbol = piece.type;
                            if (piece.color === 'white') symbol = symbol.toUpperCase();
                            fen += symbol;
                        } else {
                            empty++;
                        }
                    }
                    if (empty > 0) fen += empty;
                    if (row < 7) fen += '/';
                }

                // Active color
                fen += ' ' + (this.currentPlayer === 'white' ? 'w' : 'b');

                // Castling rights
                let castling = '';
                if (this.castlingRights.white.kingside) castling += 'K';
                if (this.castlingRights.white.queenside) castling += 'Q';
                if (this.castlingRights.black.kingside) castling += 'k';
                if (this.castlingRights.black.queenside) castling += 'q';
                fen += ' ' + (castling || '-');

                // En passant
                if (this.enPassantTarget) {
                    const col = String.fromCharCode(97 + this.enPassantTarget[1]);
                    const row = 8 - this.enPassantTarget[0];
                    fen += ' ' + col + row;
                } else {
                    fen += ' -';
                }

                // Halfmove and fullmove (simplified)
                fen += ' 0 ' + Math.floor(this.moveHistory.length / 2 + 1);

                return fen;
            }

            updateDisplay() {
                const squares = document.querySelectorAll('.square');
                squares.forEach(square => {
                    const row = parseInt(square.dataset.row);
                    const col = parseInt(square.dataset.col);
                    const piece = this.board[row][col];
                    
                    square.textContent = piece ? this.pieceSymbols[piece.color][piece.type] : '';
                    
                    square.classList.remove('selected', 'valid-move', 'in-check');
                    
                    if (this.selectedSquare && this.selectedSquare[0] === row && this.selectedSquare[1] === col) {
                        square.classList.add('selected');
                    }

                    // Highlight king in check
                    if (piece && piece.type === 'k' && this.checkStatus[piece.color]) {
                        square.classList.add('in-check');
                    }
                });

                // Update turn indicator
                const whiteIndicator = document.getElementById('white-indicator');
                const blackIndicator = document.getElementById('black-indicator');
                
                whiteIndicator.classList.toggle('current-turn', this.currentPlayer === 'white');
                blackIndicator.classList.toggle('current-turn', this.currentPlayer === 'black');
                
                // Update captured pieces
                this.updateCapturedPieces();
            }

            updateCapturedPieces() {
                const whiteCaptured = document.getElementById('white-captured');
                const blackCaptured = document.getElementById('black-captured');
                
                whiteCaptured.innerHTML = this.capturedPieces.white
                    .map(piece => `<span class="captured-piece">${this.pieceSymbols.white[piece]}</span>`)
                    .join('');
                
                blackCaptured.innerHTML = this.capturedPieces.black
                    .map(piece => `<span class="captured-piece">${this.pieceSymbols.black[piece]}</span>`)
                    .join('');
            }

            newGame() {
                this.board = this.createInitialBoard();
                this.currentPlayer = 'white';
                this.selectedSquare = null;
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.castlingRights = {
                    white: { kingside: true, queenside: true },
                    black: { kingside: true, queenside: true }
                };
                this.enPassantTarget = null;
                this.kingPositions = { white: [7, 4], black: [0, 4] };
                this.checkStatus = { white: false, black: false };
                this.updateDisplay();
            }

            undoMove() {
                if (this.moveHistory.length === 0) return;
                
                const lastMove = this.moveHistory.pop();
                const [fromRow, fromCol] = lastMove.from;
                const [toRow, toCol] = lastMove.to;
                
                // Restore the piece
                this.board[fromRow][fromCol] = lastMove.piece;
                this.board[toRow][toCol] = lastMove.captured;
                
                // Handle castling undo
                if (lastMove.castling) {
                    const [rookFromRow, rookFromCol] = lastMove.castling.rookFrom;
                    const [rookToRow, rookToCol] = lastMove.castling.rookTo;
                    this.board[rookFromRow][rookFromCol] = this.board[rookToRow][rookToCol];
                    this.board[rookToRow][rookToCol] = null;
                }
                
                // Handle en passant undo
                if (lastMove.enPassant) {
                    this.board[lastMove.enPassant.row][lastMove.enPassant.col] = lastMove.enPassant.piece;
                    this.capturedPieces[lastMove.enPassant.piece.color].pop();
                }
                
                // Restore captured pieces
                if (lastMove.captured) {
                    this.capturedPieces[lastMove.captured.color].pop();
                }
                
                // Update king position
                if (lastMove.piece.type === 'k') {
                    this.kingPositions[lastMove.piece.color] = [fromRow, fromCol];
                }
                
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                this.updateCheckStatus();
                this.updateDisplay();
            }

            setupEventListeners() {
                // Mode buttons
                document.getElementById('human-mode').addEventListener('click', () => {
                    this.gameMode = 'human';
                    document.querySelector('.mode-btn.active').classList.remove('active');
                    document.getElementById('human-mode').classList.add('active');
                    document.getElementById('ai-controls').classList.add('hidden');
                });

                document.getElementById('ai-mode').addEventListener('click', () => {
                    this.gameMode = 'ai';
                    document.querySelector('.mode-btn.active').classList.remove('active');
                    document.getElementById('ai-mode').classList.add('active');
                    document.getElementById('ai-controls').classList.remove('hidden');
                });

                // Theme controls
                document.getElementById('theme-select').addEventListener('change', (e) => {
                    this.changeTheme(e.target.value);
                });

                document.getElementById('random-theme').addEventListener('click', () => {
                    const themes = ['classic', 'neon', 'wood', 'ocean', 'sunset', 'forest', 'royal'];
                    const randomTheme = themes[Math.floor(Math.random() * themes.length)];
                    this.changeTheme(randomTheme);
                    document.getElementById('theme-select').value = randomTheme;
                });

                // Game controls
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
                document.getElementById('undo-move').addEventListener('click', () => this.undoMove());
                document.getElementById('show-hint').addEventListener('click', () => this.showHint());

                // Difficulty change
                document.getElementById('difficulty-select').addEventListener('change', (e) => {
                    this.stockfishEngine.setDifficulty(parseInt(e.target.value));
                });
            }

            changeTheme(theme) {
                const board = document.getElementById('chess-board');
                board.className = board.className.replace(/theme-\w+/, '') + ` theme-${theme}`;
            }

            showHint() {
                // Simple hint: highlight a random valid move
                const validMoves = [];
                for (let fromRow = 0; fromRow < 8; fromRow++) {
                    for (let fromCol = 0; fromCol < 8; fromCol++) {
                        const piece = this.board[fromRow][fromCol];
                        if (piece && piece.color === this.currentPlayer) {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (this.isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        validMoves.push([[fromRow, fromCol], [toRow, toCol]]);
                                    }
                                }
                            }
                        }
                    }
                }

                if (validMoves.length > 0) {
                    const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    this.selectSquare(randomMove[0][0], randomMove[0][1]);
                }
            }
        }

        // Stockfish Engine Class
        class StockfishEngine {
            constructor() {
                this.worker = null;
                this.isReady = false;
                this.isThinking = false;
                this.difficulty = 10;
                this.moveCallback = null;
                this.statusElement = document.getElementById('ai-status');
                this.initializeEngine();
            }

            async initializeEngine() {
                try {
                    this.updateStatus('loading', '🔄 Loading Stockfish...');
                    
                    // Try to load Stockfish from CDN
                    this.worker = new Worker('https://unpkg.com/stockfish@16.0.0/src/stockfish.js');
                    
                    this.worker.onmessage = (e) => this.handleMessage(e.data);
                    
                    // Initialize engine
                    this.sendCommand('uci');
                    
                    // Set a timeout to fallback if Stockfish doesn't load
                    setTimeout(() => {
                        if (!this.isReady) {
                            this.fallbackToSimpleAI();
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.log('Failed to load Stockfish:', error);
                    this.fallbackToSimpleAI();
                }
            }

            fallbackToSimpleAI() {
                this.updateStatus('ready', '🎯 Simple AI Ready');
                this.isReady = true;
            }

            handleMessage(message) {
                console.log('Stockfish:', message);
                
                if (message === 'uciok') {
                    this.sendCommand('isready');
                } else if (message === 'readyok') {
                    this.isReady = true;
                    this.updateStatus('ready', '🤖 Stockfish Ready');
                    this.sendCommand(`setoption name Skill Level value ${this.difficulty}`);
                } else if (message.startsWith('bestmove')) {
                    const move = message.split(' ')[1];
                    this.isThinking = false;
                    this.updateStatus('ready', '🤖 Stockfish Ready');
                    if (this.moveCallback) {
                        this.moveCallback(move);
                        this.moveCallback = null;
                    }
                }
            }

            sendCommand(command) {
                if (this.worker) {
                    this.worker.postMessage(command);
                }
            }

            async getBestMove(fen) {
                if (!this.isReady) {
                    return this.getSimpleAIMove(fen);
                }

                return new Promise((resolve) => {
                    if (this.worker) {
                        this.isThinking = true;
                        this.updateStatus('thinking', '🤔 Stockfish Thinking...');
                        
                        this.moveCallback = resolve;
                        this.sendCommand(`position fen ${fen}`);
                        this.sendCommand(`go depth ${Math.min(this.difficulty, 15)} movetime 2000`);
                        
                        // Timeout fallback
                        setTimeout(() => {
                            if (this.isThinking) {
                                this.isThinking = false;
                                this.updateStatus('ready', '🤖 Stockfish Ready');
                                resolve(this.getSimpleAIMove(fen));
                            }
                        }, 5000);
                    } else {
                        resolve(this.getSimpleAIMove(fen));
                    }
                });
            }

            getSimpleAIMove(fen) {
                // Simple AI fallback - return a random move
                // In a real implementation, this would analyze the position
                const game = window.chessGame;
                const validMoves = this.getAllValidMoves(game);
                
                if (validMoves.length === 0) return null;
                
                // Prefer captures
                const captures = validMoves.filter(move => game.board[move.to[0]][move.to[1]]);
                const selectedMoves = captures.length > 0 ? captures : validMoves;
                
                const randomMove = selectedMoves[Math.floor(Math.random() * selectedMoves.length)];
                return this.moveToUCI(randomMove);
            }

            getAllValidMoves(game) {
                const moves = [];
                for (let fromRow = 0; fromRow < 8; fromRow++) {
                    for (let fromCol = 0; fromCol < 8; fromCol++) {
                        const piece = game.board[fromRow][fromCol];
                        if (piece && piece.color === 'black') {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (game.isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        moves.push({
                                            from: [fromRow, fromCol],
                                            to: [toRow, toCol]
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            moveToUCI(move) {
                const fromCol = String.fromCharCode(97 + move.from[1]);
                const fromRow = 8 - move.from[0];
                const toCol = String.fromCharCode(97 + move.to[1]);
                const toRow = 8 - move.to[0];
                return fromCol + fromRow + toCol + toRow;
            }

            setDifficulty(level) {
                this.difficulty = level;
                if (this.isReady && this.worker) {
                    this.sendCommand(`setoption name Skill Level value ${level}`);
                }
            }

            updateStatus(type, message) {
                this.statusElement.className = `ai-status ${type}`;
                this.statusElement.textContent = message;
            }
        }

        // Initialize the game when the page loads
        window.chessGame = new ChessGame();
    </script>
</body>
</html>