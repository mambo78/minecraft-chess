<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Mathias Chess v6</title>
    <link rel="stylesheet" href="css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=VT323:wght@400&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <header class="header">
            <h1 class="title">üéÆ Mathias Chess v6 üéÆ</h1>
            <div class="player-info">
                <span class="white-info">White</span>
                <div class="turn-display" id="turn-display">White's Turn</div>
                <span class="black-info">Black</span>
            </div>
        </header>

        <main class="game-section">
            <div class="board-area">
                <div class="coords-left">
                    <div>8</div><div>7</div><div>6</div><div>5</div>
                    <div>4</div><div>3</div><div>2</div><div>1</div>
                </div>
                <div class="board-wrapper">
                    <div class="chess-board" id="chess-board">
                        <!-- Squares generated by JavaScript -->
                    </div>
                    <div class="coords-bottom">
                        <div>a</div><div>b</div><div>c</div><div>d</div>
                        <div>e</div><div>f</div><div>g</div><div>h</div>
                    </div>
                </div>
            </div>

            <!-- Game Controls -->
            <aside class="game-controls">
                <div class="control-section">
                    <h3>üéÆ Game Mode</h3>
                    <div class="mode-buttons">
                        <button id="human-mode-btn" class="btn mode-btn active">üë• vs Human</button>
                        <button id="ai-mode-btn" class="btn mode-btn">ü§ñ vs AI</button>
                        <button id="online-mode-btn" class="btn mode-btn">üåê Online</button>
                    </div>
                    
                    <!-- AI Controls -->
                    <div id="ai-controls" class="ai-controls" style="display: none; margin-top: 10px;">
                        <label for="ai-difficulty">AI Difficulty:</label>
                        <select id="ai-difficulty" class="select-input">
                            <option value="easy">üòä Easy</option>
                            <option value="medium" selected>ü§î Medium</option>
                            <option value="hard">üò§ Hard</option>
                            <option value="expert">üß† Expert</option>
                        </select>
                    </div>
                </div>

                <div class="control-section">
                    <h3>üé® Themes</h3>
                    <select id="theme-selector" class="select-input">
                        <option value="classic">Classic Chess</option>
                        <option value="minecraft">üéÆ Minecraft</option>
                        <option value="mario">üçÑ Mario Bros</option>
                        <option value="sonic">üí® Sonic</option>
                        <option value="pokemon">‚ö° Pok√©mon</option>
                        <option value="space">üöÄ Space</option>
                        <option value="medieval">‚öîÔ∏è Medieval</option>
                    </select>
                    <button id="random-theme-btn" class="btn">üé≤ Random Theme</button>
                </div>

                <div class="control-section">
                    <h3>Game Controls</h3>
                    <button id="new-game-btn" class="btn">üîÑ New Game</button>
                    <button id="undo-btn" class="btn">‚Ü∂ Undo Move</button>
                    <button id="hint-btn" class="btn">üí° Show Hint</button>
                </div>

                <div class="control-section">
                    <h3>Captured Pieces</h3>
                    <div class="captured-pieces">
                        <div class="captured-white" id="captured-white"></div>
                        <div class="captured-black" id="captured-black"></div>
                    </div>
                </div>
            </aside>
        </main>

        <footer class="footer">
            <div class="move-history">
                <h3>Move History</h3>
                <div id="move-list" class="move-list"></div>
            </div>
        </footer>
    </div>

    <!-- Game Message -->
    <div id="game-message" class="game-message" style="display: none;"></div>

    <!-- Pawn Promotion Dialog -->
    <div id="promotion-dialog" class="promotion-dialog" style="display: none;">
        <div class="promotion-content">
            <h3>Choose Promotion Piece</h3>
            <div class="promotion-options">
                <button class="promotion-btn" data-piece="q"><span class="piece-symbol">‚ôï</span><span>Queen</span></button>
                <button class="promotion-btn" data-piece="r"><span class="piece-symbol">‚ôñ</span><span>Rook</span></button>
                <button class="promotion-btn" data-piece="b"><span class="piece-symbol">‚ôó</span><span>Bishop</span></button>
                <button class="promotion-btn" data-piece="n"><span class="piece-symbol">‚ôò</span><span>Knight</span></button>
            </div>
        </div>
    </div>

    <script>
        // Simple but effective chess engine
        class ChessGame {
            constructor() {
                this.board = this.getStartingPosition();
                this.turn = 'white';
                this.gameMode = 'human';
                this.aiDifficulty = 'medium';
                this.moveHistory = [];
                this.selectedSquare = null;
                this.lastMove = null;
                this.capturedPieces = { white: [], black: [] };
            }

            getStartingPosition() {
                return [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
            }

            isWhitePiece(piece) {
                return piece && piece === piece.toUpperCase();
            }

            isBlackPiece(piece) {
                return piece && piece === piece.toLowerCase();
            }

            isPlayerPiece(piece, player) {
                return player === 'white' ? this.isWhitePiece(piece) : this.isBlackPiece(piece);
            }

            // Convert board coordinates to algebraic notation
            toAlgebraic(row, col) {
                return String.fromCharCode(97 + col) + (8 - row);
            }

            // Convert algebraic notation to board coordinates
            fromAlgebraic(notation) {
                const col = notation.charCodeAt(0) - 97;
                const row = 8 - parseInt(notation[1]);
                return { row, col };
            }

            // Check if a square is under attack by a player
            isSquareUnderAttack(row, col, byPlayer) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (this.isPlayerPiece(piece, byPlayer)) {
                            if (this.canPieceAttackSquare(piece, r, c, row, col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            canPieceAttackSquare(piece, fromRow, fromCol, toRow, toCol) {
                const pieceType = piece.toLowerCase();
                const isWhite = this.isWhitePiece(piece);
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;

                switch (pieceType) {
                    case 'p':
                        const direction = isWhite ? -1 : 1;
                        return rowDiff === direction && Math.abs(colDiff) === 1;
                    
                    case 'r':
                        return (rowDiff === 0 || colDiff === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    
                    case 'n':
                        return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) || 
                               (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);
                    
                    case 'b':
                        return Math.abs(rowDiff) === Math.abs(colDiff) && this.isPathClear(fromRow, fromCol, toRow, toCol);
                    
                    case 'q':
                        return ((rowDiff === 0 || colDiff === 0) || (Math.abs(rowDiff) === Math.abs(colDiff))) && 
                               this.isPathClear(fromRow, fromCol, toRow, toCol);
                    
                    case 'k':
                        return Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1;
                }
                return false;
            }

            findKing(player) {
                const kingPiece = player === 'white' ? 'K' : 'k';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] === kingPiece) {
                            return { row, col };
                        }
                    }
                }
                return null;
            }

            isInCheck(player) {
                const king = this.findKing(player);
                if (!king) return false;
                const opponent = player === 'white' ? 'black' : 'white';
                return this.isSquareUnderAttack(king.row, king.col, opponent);
            }

            isValidMove(fromRow, fromCol, toRow, toCol, promotion = null) {
                if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 || 
                    toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {
                    return false;
                }

                const piece = this.board[fromRow][fromCol];
                const targetPiece = this.board[toRow][toCol];

                if (!piece || !this.isPlayerPiece(piece, this.turn)) {
                    return false;
                }

                if (targetPiece && this.isPlayerPiece(targetPiece, this.turn)) {
                    return false;
                }

                if (!this.isValidPieceMove(piece, fromRow, fromCol, toRow, toCol)) {
                    return false;
                }

                // Check if move puts own king in check
                const tempBoard = this.board.map(row => [...row]);
                tempBoard[toRow][toCol] = piece;
                tempBoard[fromRow][fromCol] = null;
                
                const tempGame = new ChessGame();
                tempGame.board = tempBoard;
                tempGame.turn = this.turn;

                if (tempGame.isInCheck(this.turn)) {
                    return false;
                }

                return true;
            }

            isValidPieceMove(piece, fromRow, fromCol, toRow, toCol) {
                const pieceType = piece.toLowerCase();
                const isWhite = this.isWhitePiece(piece);
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                const targetPiece = this.board[toRow][toCol];

                switch (pieceType) {
                    case 'p':
                        const direction = isWhite ? -1 : 1;
                        const startRow = isWhite ? 6 : 1;

                        // Forward move
                        if (colDiff === 0 && !targetPiece) {
                            if (rowDiff === direction) return true;
                            if (fromRow === startRow && rowDiff === 2 * direction) return true;
                        }
                        // Diagonal capture
                        if (Math.abs(colDiff) === 1 && rowDiff === direction && targetPiece) {
                            return true;
                        }
                        return false;

                    case 'r':
                        return (rowDiff === 0 || colDiff === 0) && this.isPathClear(fromRow, fromCol, toRow, toCol);

                    case 'n':
                        return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) || 
                               (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);

                    case 'b':
                        return Math.abs(rowDiff) === Math.abs(colDiff) && this.isPathClear(fromRow, fromCol, toRow, toCol);

                    case 'q':
                        return ((rowDiff === 0 || colDiff === 0) || (Math.abs(rowDiff) === Math.abs(colDiff))) && 
                               this.isPathClear(fromRow, fromCol, toRow, toCol);

                    case 'k':
                        return Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1;
                }
                return false;
            }

            isPathClear(fromRow, fromCol, toRow, toCol) {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

                let row = fromRow + rowStep;
                let col = fromCol + colStep;

                while (row !== toRow || col !== toCol) {
                    if (this.board[row][col] !== null) {
                        return false;
                    }
                    row += rowStep;
                    col += colStep;
                }
                return true;
            }

            makeMove(fromRow, fromCol, toRow, toCol, promotion = null) {
                if (!this.isValidMove(fromRow, fromCol, toRow, toCol, promotion)) {
                    return false;
                }

                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];

                // Handle promotion
                let finalPiece = piece;
                if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                    if (promotion) {
                        finalPiece = this.isWhitePiece(piece) ? promotion.toUpperCase() : promotion.toLowerCase();
                    } else {
                        // Default to queen
                        finalPiece = this.isWhitePiece(piece) ? 'Q' : 'q';
                    }
                }

                // Make the move
                this.board[toRow][toCol] = finalPiece;
                this.board[fromRow][fromCol] = null;

                // Record captured piece
                if (capturedPiece) {
                    if (this.isWhitePiece(capturedPiece)) {
                        this.capturedPieces.black.push(capturedPiece);
                    } else {
                        this.capturedPieces.white.push(capturedPiece);
                    }
                }

                // Record move
                const move = {
                    from: this.toAlgebraic(fromRow, fromCol),
                    to: this.toAlgebraic(toRow, toCol),
                    piece: piece,
                    captured: capturedPiece,
                    promotion: finalPiece !== piece ? finalPiece : null
                };

                this.moveHistory.push(move);
                this.lastMove = { fromRow, fromCol, toRow, toCol };

                // Switch turns
                this.turn = this.turn === 'white' ? 'black' : 'white';

                return true;
            }

            getAllValidMoves(player) {
                const moves = [];
                for (let fromRow = 0; fromRow < 8; fromRow++) {
                    for (let fromCol = 0; fromCol < 8; fromCol++) {
                        const piece = this.board[fromRow][fromCol];
                        if (this.isPlayerPiece(piece, player)) {
                            for (let toRow = 0; toRow < 8; toRow++) {
                                for (let toCol = 0; toCol < 8; toCol++) {
                                    if (this.isValidMove(fromRow, fromCol, toRow, toCol)) {
                                        moves.push({ fromRow, fromCol, toRow, toCol, piece });
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            isCheckmate(player) {
                return this.isInCheck(player) && this.getAllValidMoves(player).length === 0;
            }

            isStalemate(player) {
                return !this.isInCheck(player) && this.getAllValidMoves(player).length === 0;
            }

            makeAIMove() {
                const moves = this.getAllValidMoves('black');
                if (moves.length === 0) return false;

                // Simple AI: prefer captures, avoid putting king in danger
                let bestMoves = moves;

                // First, prefer captures
                const captures = moves.filter(move => this.board[move.toRow][move.toCol]);
                if (captures.length > 0) {
                    bestMoves = captures;
                }

                // Pick random from best moves
                const move = bestMoves[Math.floor(Math.random() * bestMoves.length)];
                return this.makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
            }
        }

        // UI and game management
        let game = new ChessGame();
        let currentTheme = 'classic';

        const themes = {
            classic: {
                name: 'Classic Chess',
                pieces: {
                    'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
                    'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
                }
            },
            minecraft: {
                name: 'üéÆ Minecraft',
                pieces: {
                    'K': 'üëë', 'Q': 'üíé', 'R': 'üè∞', 'B': 'üó°Ô∏è', 'N': 'üêé', 'P': '‚¨ú',
                    'k': 'üéØ', 'q': 'üî•', 'r': 'üèØ', 'b': '‚öîÔ∏è', 'n': 'ü¶Ñ', 'p': '‚¨õ'
                }
            },
            mario: {
                name: 'üçÑ Mario Bros',
                pieces: {
                    'K': 'üçÑ', 'Q': '‚≠ê', 'R': 'üéÆ', 'B': 'üî¥', 'N': 'ü¶Ü', 'P': 'üü°',
                    'k': 'üëæ', 'q': 'üíÄ', 'r': 'üé≤', 'b': 'üîµ', 'n': 'üê¢', 'p': 'üü§'
                }
            },
            sonic: {
                name: 'üí® Sonic',
                pieces: {
                    'K': 'üíç', 'Q': 'üíé', 'R': 'üèÉ', 'B': '‚ö°', 'N': 'ü¶î', 'P': 'üíô',
                    'k': 'ü§ñ', 'q': 'üíÄ', 'r': 'üöÅ', 'b': 'üî¥', 'n': 'üëπ', 'p': 'üñ§'
                }
            },
            pokemon: {
                name: '‚ö° Pok√©mon',
                pieces: {
                    'K': '‚ö°', 'Q': 'üî•', 'R': 'üíß', 'B': 'üçÉ', 'N': 'üåü', 'P': '‚ö™',
                    'k': 'üåô', 'q': '‚ùÑÔ∏è', 'r': 'üåä', 'b': 'üå∫', 'n': '‚ú®', 'p': '‚ö´'
                }
            },
            space: {
                name: 'üöÄ Space',
                pieces: {
                    'K': 'üöÄ', 'Q': 'üõ∏', 'R': 'üåç', 'B': 'üåü', 'N': 'üëΩ', 'P': 'üîµ',
                    'k': 'üåë', 'q': '‚òÑÔ∏è', 'r': 'ü™ê', 'b': '‚≠ê', 'n': 'üëæ', 'p': 'üî¥'
                }
            },
            medieval: {
                name: '‚öîÔ∏è Medieval',
                pieces: {
                    'K': 'üëë', 'Q': 'üë∏', 'R': 'üè∞', 'B': '‚õ™', 'N': 'üê¥', 'P': 'üõ°Ô∏è',
                    'k': 'ü§¥', 'q': 'üßô‚Äç‚ôÄÔ∏è', 'r': 'üèØ', 'b': 'üóø', 'n': 'üêâ', 'p': '‚öîÔ∏è'
                }
            }
        };

        let pieceSymbols = themes.classic.pieces;

        function initGame() {
            createBoard();
            updateBoard();
            setupControls();
            showMessage('‚úÖ Chess game loaded successfully!', 2000);
        }

        function createBoard() {
            const boardElement = document.getElementById('chess-board');
            boardElement.innerHTML = '';
            
            for (let rank = 8; rank >= 1; rank--) {
                for (let file = 0; file < 8; file++) {
                    const square = document.createElement('div');
                    const isLight = (rank + file) % 2 === 0;
                    
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.rank = rank - 1;
                    square.dataset.file = file;
                    square.addEventListener('click', () => handleSquareClick(rank - 1, file));
                    
                    boardElement.appendChild(square);
                }
            }
        }

        function updateBoard() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const rank = parseInt(square.dataset.rank);
                const file = parseInt(square.dataset.file);
                const piece = game.board[7-rank][file];
                
                square.textContent = piece ? (pieceSymbols[piece] || piece) : '';
                square.classList.remove('selected', 'last-move', 'valid-move', 'in-check');
                
                // Highlight selected square
                if (game.selectedSquare && game.selectedSquare.rank === rank && game.selectedSquare.file === file) {
                    square.classList.add('selected');
                }
                
                // Highlight last move
                if (game.lastMove) {
                    if ((game.lastMove.fromRow === 7-rank && game.lastMove.fromCol === file) ||
                        (game.lastMove.toRow === 7-rank && game.lastMove.toCol === file)) {
                        square.classList.add('last-move');
                    }
                }
                
                // Highlight king in check
                if (piece && piece.toLowerCase() === 'k') {
                    const player = game.isWhitePiece(piece) ? 'white' : 'black';
                    if (game.isInCheck(player)) {
                        square.classList.add('in-check');
                    }
                }
            });
            
            updateTurnDisplay();
            updateMoveHistory();
            updateCapturedPieces();
        }

        function handleSquareClick(rank, file) {
            const boardRow = 7 - rank;
            const piece = game.board[boardRow][file];
            
            if (game.selectedSquare) {
                const fromRow = 7 - game.selectedSquare.rank;
                const fromCol = game.selectedSquare.file;
                
                if (game.selectedSquare.rank === rank && game.selectedSquare.file === file) {
                    // Deselect
                    game.selectedSquare = null;
                    clearHighlights();
                } else {
                    // Try to make move
                    const moveSuccessful = game.makeMove(fromRow, fromCol, boardRow, file);
                    game.selectedSquare = null;
                    clearHighlights();
                    
                    if (moveSuccessful) {
                        updateBoard();
                        
                        // Check game end
                        if (game.isCheckmate(game.turn)) {
                            const winner = game.turn === 'white' ? 'Black' : 'White';
                            showMessage(`üèÜ Checkmate! ${winner} wins!`, 0);
                        } else if (game.isStalemate(game.turn)) {
                            showMessage('ü§ù Stalemate! It\'s a draw!', 0);
                        } else if (game.isInCheck(game.turn)) {
                            showMessage(`‚ö†Ô∏è ${game.turn === 'white' ? 'White' : 'Black'} is in check!`, 3000);
                        }
                        
                        // AI move
                        if (game.gameMode === 'ai' && game.turn === 'black') {
                            setTimeout(() => {
                                if (game.makeAIMove()) {
                                    updateBoard();
                                    
                                    // Check game end after AI move
                                    if (game.isCheckmate(game.turn)) {
                                        showMessage('üèÜ AI wins!', 0);
                                    } else if (game.isStalemate(game.turn)) {
                                        showMessage('ü§ù Stalemate! It\'s a draw!', 0);
                                    }
                                }
                            }, 500);
                        }
                    }
                }
            } else {
                // Select piece
                if (piece && game.isPlayerPiece(piece, game.turn)) {
                    if (game.gameMode === 'ai' && game.turn === 'black') {
                        return; // Don't allow selecting AI pieces
                    }
                    
                    game.selectedSquare = { rank, file };
                    highlightValidMoves(boardRow, file);
                }
            }
            
            updateBoard();
        }

        function highlightValidMoves(fromRow, fromCol) {
            clearHighlights();
            const squares = document.querySelectorAll('.square');
            
            for (let toRow = 0; toRow < 8; toRow++) {
                for (let toCol = 0; toCol < 8; toCol++) {
                    if (game.isValidMove(fromRow, fromCol, toRow, toCol)) {
                        const square = squares[toRow * 8 + toCol];
                        if (square) {
                            square.classList.add('valid-move');
                        }
                    }
                }
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('valid-move');
            });
        }

        function updateTurnDisplay() {
            const turnDisplay = document.getElementById('turn-display');
            
            if (game.isCheckmate(game.turn)) {
                const winner = game.turn === 'white' ? 'Black' : 'White';
                turnDisplay.textContent = `${winner} Wins!`;
            } else if (game.isStalemate(game.turn)) {
                turnDisplay.textContent = 'Stalemate!';
            } else if (game.gameMode === 'ai') {
                if (game.turn === 'white') {
                    turnDisplay.textContent = 'Your Turn';
                } else {
                    turnDisplay.textContent = 'ü§ñ AI Turn';
                }
            } else {
                turnDisplay.textContent = `${game.turn === 'white' ? 'White' : 'Black'}'s Turn`;
            }
        }

        function updateMoveHistory() {
            const moveList = document.getElementById('move-list');
            let historyHTML = '';
            
            for (let i = 0; i < game.moveHistory.length; i += 2) {
                const moveNumber = Math.floor(i / 2) + 1;
                const whiteMove = game.moveHistory[i] ? `${game.moveHistory[i].from}${game.moveHistory[i].to}` : '';
                const blackMove = game.moveHistory[i + 1] ? `${game.moveHistory[i + 1].from}${game.moveHistory[i + 1].to}` : '';
                
                historyHTML += `<div>${moveNumber}. ${whiteMove} ${blackMove}</div>`;
            }
            
            moveList.innerHTML = historyHTML;
            moveList.scrollTop = moveList.scrollHeight;
        }

        function updateCapturedPieces() {
            const whiteCaptured = document.getElementById('captured-white');
            const blackCaptured = document.getElementById('captured-black');
            
            whiteCaptured.innerHTML = game.capturedPieces.white.map(p => pieceSymbols[p] || p).join(' ');
            blackCaptured.innerHTML = game.capturedPieces.black.map(p => pieceSymbols[p] || p).join(' ');
        }

        function changeTheme(themeName) {
            if (themes[themeName]) {
                currentTheme = themeName;
                pieceSymbols = themes[themeName].pieces;
                updateBoard();
                showMessage(`Theme changed to ${themes[themeName].name}! üé®`, 2000);
            }
        }

        function setupControls() {
            // New game
            document.getElementById('new-game-btn').addEventListener('click', () => {
                game = new ChessGame();
                game.gameMode = document.getElementById('ai-mode-btn').classList.contains('active') ? 'ai' : 'human';
                updateBoard();
                showMessage('üîÑ New game started!', 2000);
            });

            // Game modes
            document.getElementById('human-mode-btn').addEventListener('click', () => {
                game.gameMode = 'human';
                document.getElementById('human-mode-btn').classList.add('active');
                document.getElementById('ai-mode-btn').classList.remove('active');
                document.getElementById('online-mode-btn').classList.remove('active');
                document.getElementById('ai-controls').style.display = 'none';
                showMessage('üë• Human vs Human mode!', 2000);
                updateTurnDisplay();
            });
            
            document.getElementById('ai-mode-btn').addEventListener('click', () => {
                game.gameMode = 'ai';
                document.getElementById('ai-mode-btn').classList.add('active');
                document.getElementById('human-mode-btn').classList.remove('active');
                document.getElementById('online-mode-btn').classList.remove('active');
                document.getElementById('ai-controls').style.display = 'block';
                showMessage('ü§ñ AI mode! You are White.', 2000);
                updateTurnDisplay();
            });

            document.getElementById('online-mode-btn').addEventListener('click', () => {
                showMessage('üåê Online mode coming soon!', 2000);
            });

            // AI difficulty
            document.getElementById('ai-difficulty').addEventListener('change', (e) => {
                game.aiDifficulty = e.target.value;
                showMessage(`AI difficulty set to ${e.target.options[e.target.selectedIndex].text}`, 2000);
            });

            // Themes
            document.getElementById('theme-selector').addEventListener('change', (e) => {
                changeTheme(e.target.value);
            });

            document.getElementById('random-theme-btn').addEventListener('click', () => {
                const themeNames = Object.keys(themes);
                const randomTheme = themeNames[Math.floor(Math.random() * themeNames.length)];
                document.getElementById('theme-selector').value = randomTheme;
                changeTheme(randomTheme);
            });

            // Undo move
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (game.moveHistory.length > 0) {
                    // Simple undo: restart and replay all moves except the last one(s)
                    const movesToReplay = game.gameMode === 'ai' ? 
                        game.moveHistory.slice(0, -2) : // Undo player and AI move
                        game.moveHistory.slice(0, -1);  // Undo last move
                    
                    game = new ChessGame();
                    game.gameMode = document.getElementById('ai-mode-btn').classList.contains('active') ? 'ai' : 'human';
                    
                    // Replay moves
                    movesToReplay.forEach(move => {
                        const from = game.fromAlgebraic(move.from);
                        const to = game.fromAlgebraic(move.to);
                        game.makeMove(from.row, from.col, to.row, to.col, move.promotion);
                    });
                    
                    updateBoard();
                    showMessage('‚Ü∂ Move undone!', 2000);
                } else {
                    showMessage('‚ùå No moves to undo!', 2000);
                }
            });

            // Hint
            document.getElementById('hint-btn').addEventListener('click', () => {
                const moves = game.getAllValidMoves(game.turn);
                if (moves.length > 0) {
                    const hint = moves[Math.floor(Math.random() * moves.length)];
                    const from = game.toAlgebraic(hint.fromRow, hint.fromCol);
                    const to = game.toAlgebraic(hint.toRow, hint.toCol);
                    showMessage(`üí° Try moving from ${from} to ${to}`, 3000);
                } else {
                    showMessage('‚ùå No valid moves available!', 2000);
                }
            });
        }

        function showMessage(message, duration = 3000) {
            const messageElement = document.getElementById('game-message');
            messageElement.textContent = message;
            messageElement.style.display = 'block';
            messageElement.style.background = message.includes('‚ùå') || message.includes('‚ö†Ô∏è') ? 
                'rgba(231, 76, 60, 0.9)' : 'rgba(46, 204, 113, 0.9)';
            messageElement.style.color = 'white';
            messageElement.style.padding = '10px 20px';
            messageElement.style.borderRadius = '5px';
            messageElement.style.position = 'fixed';
            messageElement.style.top = '20px';
            messageElement.style.left = '50%';
            messageElement.style.transform = 'translateX(-50%)';
            messageElement.style.zIndex = '1000';
            
            if (duration > 0) {
                setTimeout(() => {
                    messageElement.style.display = 'none';
                }, duration);
            }
        }

        // Initialize game
        document.addEventListener('DOMContentLoaded', initGame);
        if (document.readyState !== 'loading') {
            initGame();
        }
    </script>

    <style>
        .last-move {
            background-color: rgba(255, 255, 0, 0.3) !important;
        }
        
        .valid-move {
            position: relative;
        }
        
        .valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background-color: rgba(0, 255, 0, 0.5);
            border-radius: 50%;
        }
        
        .in-check {
            background-color: rgba(255, 0, 0, 0.5) !important;
        }
        
        .ai-controls {
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .ai-controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .promotion-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .promotion-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        
        .promotion-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .promotion-btn {
            padding: 10px;
            border: 2px solid #333;
            background-color: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .promotion-btn:hover {
            background-color: #f0f0f0;
        }
        
        .piece-symbol {
            display: block;
            font-size: 24px;
            margin-bottom: 5px;
        }
    </style>
</body>
</html>